<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<style type="text/css">
  #main {
    width: 600px;
    height: 600px;
    margin-left: 60px;
    margin-top: 60px;
  }

  #tip {
    width: 100px;
    background-color: rgba(0, 0, 0, 0.3);
    position: absolute;
    color: white;
    text-align: center;
    margin: 5px;
    box-sizing: border-box;
  }
</style>

<body>
  <div id="main"></div>
  <script src="https://unpkg.com/d3@7.6.1/dist/d3.min.js"></script>
  <script>
    const [width, height] = [600, 600];
    const main = d3.select("#main");
    const svg = main.append('svg')
      // .attr('version', '1.2')
      // .attr('xmlns', 'http://www.w3.org/2000/svg')
      .attr('width', '100%')
      .attr('height', '100%')
      .attr('viewBox', `0 0 ${width} ${height}`);
    /*category 类目数据*/
    const category = ['html', 'css', 'js','go'];
    const len = category.length;
    /*用range()方法，基于类目数量，获取x轴的在图表坐标系中的数据 xChartData，如[0,1,2]*/
    const xChartData = d3.range(len);
    /*x轴在像素坐标内的起始点和结束点 xPixelRange，左右各偏移50*/
    const xPixelData = [50, width - 50];
    /*
        * 用scaleBand()方法建立分段比例尺 xScale
        * 用domain()方法在比例尺中写入图表数据xChartData
        * 用rangeRound()方法在比例尺中写入像素数据，即像素的起始位和结束位xPixelRange
        * */
    const xScale = d3.scaleBand().domain(xChartData).rangeRound(xPixelData).padding(0.1);
    /*基于比例尺xScale，用axisBottom()方法创建刻度朝下的坐标轴生成器 xAxisGenerator*/
    const xAxisGenerator = d3.axisBottom(xScale)
    /*利用坐标轴生成器绘制坐标轴
    *   在svg中append 加入g 对象
    *   用attr() 方法设置transform 属性中的translate位置
    *   用call()方法调用xAxisGenerator轴生成器，生成坐标轴
    *   用selectAll()方法选择所有的text文本
    *   用text()方法将图表数据设置为类目数据
    *   用style()方法设置字体大小
    * */
    svg.append('g')
      .attr('transform', `translate(0 ${height - 50})`)
      .call(xAxisGenerator)
      .selectAll('text')
      .text((d, i) => category[i])
      .style('font-size', '12px')//默认字体大小为10px
    const source = [
      //html css js
      [30, 20, 40,40],//学习人数
      [40, 30, 50,40], //就业人数
      [50, 30, 20,70], //就业人数z
      // [50, 30, 20], //就业人数z
    ]
    const maxY = Math.max(...source.flat())

    /*声明y轴在图表坐标系中的数据起点和结束点 yChartRange*/
    const yChartRange = [0, maxY]

    /*声明y轴在像素坐标系中的数据起点和结束点 yPixelRange*/
    const yPixelRange = [height - 50, 50]

    //线性数据使用scaleLinear
    const yScale = d3.scaleLinear()
      .domain(yChartRange)
      .range(yPixelRange)
    const yAxisGenerator = d3.axisLeft(yScale)
    svg.append('g')
      .attr('transform', 'translate(50,0)')
      .call(yAxisGenerator)
      .style('font-size', '12px')
    //调色盘
    const color = ['pink', 'darkblue', '#c23531', '#2f4554']
    /*用x轴比例尺xScale的bandwidth()方法获取x轴上一个类目的像素宽xBandW*/
    const sBandW = xScale.bandwidth();

    /*获取系列的数量n*/
    const n = source.length;
    console.log(n,'n..')

    /*用类目宽除以系列数，得到一个类目中每个系列元素的宽，即列宽colW*/
    const colW = sBandW / n;

    /*计算调色盘颜色数量colorLen*/
    const colorLen = color.length
    const seriesObjs = svg.append('g')
      .selectAll()
      .data(source)
      .join('g')
      .attr('transform', (seriesData, seriesInd) => {
        const seriesX = seriesInd * colW
        return `translate(${seriesX} 0)`
      })
      .attr('fill', (seriesData, seriesInd) => {
        console.log(color[seriesInd % colorLen],'12')
        console.log(seriesInd,'11')
        console.log(colorLen,'13')
        return color[seriesInd % colorLen]
      })
    /*在系列集合中建立柱状体集合rects
*   用系列集合seriesObjs 的selectAll()方法选择所有的rect元素，用于建立选择集对象
*   用data()方法将之前绑定在每个系列集合中的数据绑定到柱状体集合中
*   用join()基于每个系列的数据数据批量创建rect元素
*   用classed() 方法为其添加item属性
* */
    const rects = seriesObjs.selectAll('g')
      .data(seriesData => seriesData)
      .join('rect')
      .classed('item', true)
    rects.attr('x', (rectData, rectInd) => xScale(rectInd))
      .attr('width', colW)
      .attr('y', (rectData, rectInd) => yScale(rectData))
      .attr('height', (rectData, rectInd) => yScale(0) - yScale(rectData))
    // ===========================================================
    const dimensions = ["学习人数", "就业人数"];
    const source2 = source.map((seriesData, seriesInd) => {
      const seriesName = dimensions[seriesInd]
      return seriesData.map((rectData, rectInd) => {
        const rectName = category[rectInd]
        return { rectData, rectInd, rectName, seriesInd, seriesName }
      })
    })
  console.log(source,source2,'1')
    // rects.attr('x', ({ rectData, rectInd }) => xScale(rectInd))
    //   .attr('width', colW)
    //   .attr('y', ({ rectData, rectInd }) => yScale(rectData))
    //   .attr('height', ({ rectData, rectInd }) => yScale(0) - yScale(rectData))

    // //建立提示对象
    const tip = main.append('div')
      .attr('id', 'tip')

    // //鼠标悬浮事件
    rects.on('mouseover', ({ clientX, clientY }, { rectData, seriesName, rectName }) => {
      tip.style('display', 'block')
        .style('left', clientX + 'px')
        .style('top', clientY + 'px')
        .html(`
              <div>${rectName}</div>
              <div>${seriesName}：${rectData}</div>
          `)
    })
    rects.on('mousemove', ({ clientX, clientY }) => {
      tip.style('left', clientX + 'px')
        .style('top', clientY + 'px')
    })
    /*隐藏提示*/
    rects.on('mouseout', ({ clientX, clientY }) => {
      tip.style('display', 'none')
    })
  </script>
</body>

</html>